<div id="directory" class="section">
  <h1>RequireJS API</h1>
  <span class="note">This is the <a href="https://github.com/jrburke/requirejs/wiki/Upgrading-to-RequireJS-2.0">RequireJS 2.0 API</a>. If you want 1.0: <a href="1.0/">Link to 1.0</a>.</span>
  <ul class="index mono">
    <li class="hbox"><a href="#usage">Usage</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 1 &ndash; 1.4</span>
      <ul>
        <li class="hbox"><a href="#jsfiles">Loading JavaScript Files</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.1</span></li>
        <li class="hbox"><a href="#data-main">data-main Entry Point</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2</span></li>
        <li class="hbox"><a href="#define">Defining a Module</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3</span>
          <ul>
            <li class="hbox"><a href="#defsimple">Simple Name/Value Pairs</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.1</span></li>
            <li class="hbox"><a href="#deffunc">Definition Functions</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.2</span></li>
            <li class="hbox"><a href="#defdep">Definition Functions with Dependencies</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.3</span></li>
            <li class="hbox"><a href="#funcmodule">Define a Module as a Function</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.4</span></li>
            <li class="hbox"><a href="#cjsmodule">Define a Module with Simplified CommonJS Wrapper</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.5</span></li>
            <li class="hbox"><a href="#modulename">Define a Module with a name</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.6</span></li>
            <li class="hbox"><a href="#modulenotes">Other Module Notes</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.7</span></li>
            <li class="hbox"><a href="#circular">Circular Dependencies</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.8</span></li>
            <li class="hbox"><a href="#jsonp">Specify a JSONP Service Dependency</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.9</span></li>
            <li class="hbox"><a href="#undef">Undefining a Module</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3.10</span></li>
          </ul>
        </li>
        <li class="hbox"><a href="#reference">Referencing a Module</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.4</span>
          <ul>
            <li class="hbox"><a href="#moduleID">What is a Module ID?</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.4.1</span></li>
            <li class="hbox"><a href="#require">Executing code with dependencies: require()</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.4.2</span></li>
          </ul>
        </li>
      </ul>
    </li>
    <li class="hbox"><a href="#mechanics">Mechanics</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 2</span></li>
    <li class="hbox"><a href="#config">Configuration Options</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 3</span>
      <ul>
        <li class="hbox"><a href="#config-baseUrl">baseUrl</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-paths">paths</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-bundles">bundles</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-shim">shim</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-map">map</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-moduleconfig">config</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-packages">packages</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-nodeIdCompat">nodeIdCompat</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-waitSeconds">waitSeconds</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-context">context</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-deps">deps</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-callback">callback</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-enforceDefine">enforceDefine</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-xhtml">xhtml</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-urlArgs">urlArgs</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-scriptType">scriptType</a><span class="spacer boxFlex"></span></li>
        <li class="hbox"><a href="#config-skipDataMain">skipDataMain</a><span class="spacer boxFlex"></span></li>
      </ul>
    </li>
    <li class="hbox"><a href="#advanced">Advanced Usage</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 4 &ndash; 4.6</span>
      <ul>
        <li class="hbox"><a href="#packages">Loading Modules from Packages</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.1</span></li>
        <li class="hbox"><a href="#multiversion">Multiversion Support</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.2</span></li>
        <li class="hbox"><a href="#afterload">Loading Code After Page Load</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.3</span></li>
        <li class="hbox"><a href="#webworker">Web Worker Support</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.4</span></li>
        <li class="hbox"><a href="#rhino">Rhino Support</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.5</span></li>
        <li class="hbox"><a href="#nashorn">Nashorn Support</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.6</span></li>
        <li class="hbox"><a href="#errors">Handling Errors</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.7</span></li>
      </ul>
    </li>
    <li class="hbox"><a href="#plugins">Loader Plugins</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 5 &ndash; 5.4</span>
      <ul>
        <li class="hbox"><a href="#text">Specify a Text File Dependency</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5.1</span></li>
        <li class="hbox"><a href="#pageload">Page Load Event Support/DOM Ready</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5.2</span></li>
        <li class="hbox"><a href="#i18n">Define an I18N Bundle</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5.3</span></li>
      </ul>
    </li>
  </ul>
</div>
<div class="section">
  <h2>
    <a href="#usage" name="usage">Usage</a>
    <span class="sectionMark">&sect; 1</span>
  </h2>
  <h3>
    <a href="#jsfiles" name="jsfiles">Loading JavaScript Files</a>
    <span class="sectionMark">&sect; 1.1</span>
  </h3>
  <p>In common Internet browser environments, JavaScript code is loaded by referencing JavaScript files using &lt;script&gt; tags. Referencing these files in an SGML derived language puts the
      responsibility for loading JavaScript code to an entity which has no notion of the actual dependency of each of the files to load.</p>
  <p>RequireJS, however, takes an approach on loading JavaScript code which is quite different from loading files via traditional &lt;script&gt; tags: The code to be loaded is controlled from within
      the currently running JavaScript code.</p>
  <p>The advantage of this approach is that JavaScript code only gets loaded when it is actually required by the currently running code.</p>
  <p>The primary goal of this approach is to encourage modular code. But it also performs fast and will optimize well. As part of regarding JavaScript entities as modules, RequireJS
      encourages to reference JavaScript files by what we call <strong>module IDs</strong> instead of URLs for script tags.</p>
  <p>RequireJS will load all code relative to a <a href="#config-baseUrl">baseUrl</a>. If not overriden in configuration, the baseUrl will be the same directory where the script is stored that's
      being referenced in the <a href="#data-main">data-main</a> attribute for the top level script to load for a page. The <strong>data-main</strong> attribute is a special attribute which
      requireJS will read when it's beginning to load scripts.</p>
  <p>The following example will set the <strong>baseUrl</strong> to <strong>"./scripts"</strong>:</p>
  <pre><code>&lt;!--This sets the baseUrl to the "./scripts" directory, and
    loads a script that will have a module ID of 'main'--&gt;
&lt;script data-main="scripts/main.js" src="lib/require.js"&gt;&lt;/script&gt;
</code></pre>
  <p>The <strong>baseUrl</strong> can also be set manually using the RequireJS <a href="#config">configuration</a> object. If there is no explicit <strong>configuration</strong> object and
      <strong>data-main</strong> is not used either, then the <strong>baseUrl</strong> will default to the directory containing the HTML page running RequireJS (in the above example this directory
      would be <code>"."</code>).</p>

  <p>RequireJS also assumes that all dependencies are scripts, so it does not expect a trailing ".js" suffix in <strong>module ID</strong> references. When translating a module ID to a path RequireJS
      will automatically add the ".js" suffix.</p>
  <p>Using the <a href="#config-paths">paths</a> property of the <a href="#config">configuration</a> object, you can set up aliases for script directories. This will add abstraction to the actual
      folder structure and allow for easy, central modification if the document tree changes.</p>
  <p>All of these capabilities allow you to use smaller strings for scripts as compared to traditional <code>&lt;script&gt;</code> tags.
  </p>
  <p>There may be times when you do want to reference a script directly instead of relying on the "baseUrl + paths" rules for finding it. If a module ID reference matches at least one of the following
      characteristics, the value will not be processed by the "baseUrl + paths" configuration, but it will be treated like a regular plain URL instead, relative to the document:</p>
  <ul>
    <li>Ends with ".js".</li>
    <li>Starts with a "/".</li>
    <li>Contains an URL protocol, like "http:" or "https:".</li>
  </ul>
  <p>In general though, it is best to use the <a href="#config-baseUrl">baseUrl</a> and <a href="#config-paths">paths</a> configuration properties to set paths for module IDs. By doing so, it gives you more
      flexibility in renaming and configuring the paths to different locations for optimized builds.</p>
  <p>Similarly, to avoid a bunch of configuration, it is preferred to avoid deep folder hierarchies for scripts, and instead either keep all the scripts in baseUrl, or if you want to
      separate your library/vendor-supplied code from your app code, use a directory layout similar to this:</p>
  <ul>
    <li>www/
        <ul>
          <li>index.html</li>
          <li>js/
            <ul>
              <li>app/
                <ul>
                  <li>sub.js</li>
                </ul>
              </li>
              <li>lib/
                <ul>
                  <li>jquery.js</li>
                  <li>canvas.js</li>
                </ul>
              </li>
              <li>app.js</li>
              <li>require.js</li>
            </ul>
          </li>
        </ul>
    </li>
  </ul>
  <p>in index.html:</p>
  <pre><code>&lt;script data-main="js/app.js" src="js/require.js"&gt;&lt;/script&gt;</code></pre>
  <p>and in app.js:</p>
  <pre><code>requirejs.config({
    // load module IDs relative to "./js/lib"
    baseUrl: 'js/lib',

    // If the module ID begins with "app", replace
    // "app" with "../app" when searching for the
    // corresponding JavaScript file.
    // "paths" config is relative to the baseUrl, and
    // never includes a ".js" extension since
    // "paths" items usually evaluate to a directory.
    paths: {
        app: '../app'
    }
});

// Start the main app logic.
requirejs(['jquery', 'canvas', 'app/sub'],
function   ($,        canvas,   sub) {
    //jQuery, canvas and the app/sub module are all
    //loaded and can be used here now.
});
</code></pre>
  <p>Notice as part of the above example, vendor libraries like jQuery did not have their version numbers in their file names. It is recommended to store that version info in a separate text file if you
      want to track it, or if you use a tool like <a href="https://github.com/volojs/volo">volo</a>, it will stamp the package.json with the version information but keep the file on disk as "jquery.js".
      This allows you to have the very minimal configuration instead of having to put an entry in the "paths" configuration for each library.</p>
  <p>Ideally the scripts you load will be modules that are defined by calling RequireJS's <a href="#define">define()</a>. However, if you need to use some traditional/legacy "browser globals" scripts that
      do not express their dependencies via <strong>define()</strong>, you can use the <a href="#config-shim">shim</a> property of the <strong>configuration</strong> object to properly express their dependencies.
      Using the <strong>shim</strong> configuration property you can add meta information to legacy libraries so they can be referenced like they had been defined using <a href="#define">define()</a>.
  </p>
  <p>If you do not set dependencies for legacy code using <strong>shim</strong> configuration property items, you will likely get loading errors since RequireJS loads scripts asynchronously and out of order
      for speed. It cannot synchronize dependency with code loaded by the &lt;script&gt; tag.</p>
  <h3>
    <a href="#data-main" name="data-main">data-main Entry Point</a>
    <span class="sectionMark">&sect; 1.2</span>
  </h3>
  <p>The data-main attribute is a special attribute that require.js will check to start script loading:</p>
  <pre><code>&lt;!--when require.js loads it will inject another script tag
    (with async attribute) for scripts/main.js--&gt;
&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>
  <p>You will typically use a data-main script to <a href="#config">set configuration options</a> and then load the first application module. Note: the script tag require.js generates for your data-main module includes the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async">async attribute</a>. This means that <strong>you cannot assume that the load and execution of your data-main script will finish prior to other scripts referenced later in the same page.</strong></p>
  <p>For example, this arrangement will fail randomly when the require.config path for the 'foo' module has not been set prior to it being require()'d later:</p>
  <pre><code>&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script src="scripts/other.js"&gt;&lt;/script&gt;
</code></pre>
  <pre><code>// contents of main.js:
require.config({
    paths: {
        foo: 'libs/foo-1.1.3'
    }
});
</code></pre>
  <pre><code>// contents of other.js:
// This code might be called before the require.config() in main.js
// has executed. When that happens, require.js will attempt to
// load 'scripts/foo.js' instead of 'scripts/libs/foo-1.1.3.js'
require(['foo'], function(foo) {
});
</code></pre>
  <p>If you want to do <code>require()</code> calls in the HTML page, then it is best to not use data-main. data-main is only intended for use when the page just has one main entry point, the data-main script. For pages that want to do inline <code>require()</code> calls, it is best to nest those inside a <code>require()</code> call for the configuration:</p>
  <pre><code>&lt;script src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script&gt;
require(['scripts/config'], function() {
    // Configuration loaded now, safe to do other require calls
    // that depend on that config.
    require(['foo'], function(foo) {
    });
});
&lt;/script&gt;
</code></pre>
  <h3>
    <a href="#define" name="define">Defining a Module</a>
    <span class="sectionMark">&sect; 1.3</span>
  </h3>
  <p>A module is different from a traditional script file in that it defines a well-scoped object that avoids polluting the global namespace. It can explicitly list its dependencies and get a handle on those dependencies without needing to refer to global objects, but instead receive the dependencies as arguments to the function that defines the module. Modules in RequireJS are an extension of the <a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">Module Pattern</a>, with the benefit of not needing globals to refer to other modules.</p>
  <p>The RequireJS syntax for modules allows them to be loaded as fast as possible, even out of order, but evaluated in the correct dependency order, and since global variables are not created, it makes it possible to <a href="#multiversion">load multiple versions of a module in a page</a>.</p>
  <p>(If you are familiar with or are using CommonJS modules, then please also see <a href="commonjs.html">CommonJS Notes</a> for information on how the RequireJS module format maps to CommonJS modules).</p>
  <p>There should only be <strong>one</strong> module definition per file on disk. The modules can be grouped into optimized bundles by the <a href="optimization.html">optimization tool</a>.</p>
  <div class="subSection">
    <h4>
      <a href="#defsimple" name="defsimple">Simple Name/Value Pairs</a>
      <span class="sectionMark">&sect; 1.3.1</span>
    </h4>
    <p>If the module does not have any dependencies, and it is just a collection of name/value pairs, then just pass an object literal to define():</p>
    <pre><code>//Inside file my/shirt.js:
define({
    color: "black",
    size: "unisize"
});
</code></pre>
  </div>
  <div class="subSection">
    <h4>
      <a href="#deffunc" name="deffunc">Definition Functions</a>
      <span class="sectionMark">&sect; 1.3.2</span>
    </h4>
    <p>If the module does not have dependencies, but needs to use a function to do some setup work, then define itself, pass a function to define():</p>
    <pre><code>//my/shirt.js now does setup work
//before returning its module definition.
define(function () {
    //Do setup work here
    return {
        color: "black",
        size: "unisize"
    }
});
</code></pre>
  </div>
  <div class="subSection">
    <h4><a href="#defdep" name="defdep">Definition Functions with Dependencies</a><span class="sectionMark">&sect; 1.3.3</span></h4>
    <p>If the module has dependencies, the first argument should be an array of dependency names, and the second argument should be a definition function. The function will be called to define the module once all dependencies have loaded. The function should return an object that defines the module. The dependencies will be passed to the definition function as function arguments, listed in the same order as the order in the dependency array:</p>
    <pre><code>//my/shirt.js now has some dependencies, a cart and inventory
//module in the same directory as shirt.js
define(["./cart", "./inventory"], function(cart, inventory) {
        //return an object to define the "my/shirt" module.
        return {
            color: "blue",
            size: "large",
            addToCart: function() {
                inventory.decrement(this);
                cart.add(this);
            }
        }
    }
);
</code></pre>
    <p>In this example, a my/shirt module is created. It depends on my/cart and my/inventory. On disk, the files are structured like this:</p>
    <ul>
      <li>my/cart.js</li>
      <li>my/inventory.js</li>
      <li>my/shirt.js</li>
    </ul>
    <p>The function call above specifies two arguments, "cart" and "inventory". These are the modules represented by the "./cart" and "./inventory" module names.</p>
    <p>The function is not called until the my/cart and my/inventory modules have been loaded, and the function receives the modules as the "cart" and "inventory" arguments.</p>
    <p>Modules that define globals are explicitly discouraged, so that multiple versions of a module can exist in a page at a time (see <strong>Advanced Usage</strong>). Also, the order of the function arguments should match the order of the dependencies.</p>
    <p>The return object from the function call defines the "my/shirt" module. By defining modules in this way, "my/shirt" does not exist as a global object.</p>
  </div>
  <div class="subSection">
    <h4><a href="#funcmodule" name="funcmodule">Define a Module as a Function</a><span class="sectionMark">&sect; 1.3.4</span></h4>
    <p>Modules do not have to return objects. Any valid return value from a function is allowed. Here is a module that returns a function as its module definition:</p>
    <pre><code>//A module definition inside foo/title.js. It uses
//my/cart and my/inventory modules from before,
//but since foo/title.js is in a different directory than
//the "my" modules, it uses the "my" in the module dependency
//name to find them. The "my" part of the name can be mapped
//to any directory, but by default, it is assumed to be a
//sibling to the "foo" directory.
define(["my/cart", "my/inventory"],
    function(cart, inventory) {
        //return a function to define "foo/title".
        //It gets or sets the window title.
        return function(title) {
            return title ? (window.title = title) :
                    inventory.storeName + ' ' + cart.name;
        }
    }
);
</code></pre>
  </div>

  <div class="subSection">
    <h4><a href="#cjsmodule" name="cjsmodule">Define a Module with Simplified CommonJS Wrapper</a><span class="sectionMark">&sect; 1.3.5</span></h4>
    <p>If you wish to reuse some code that was written in the traditional <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS module format</a> it may be difficult to re-work to the array of dependencies used above, and you may prefer to have
        direct alignment of dependency name to the local variable used for that dependency. You can use the <a href="commonjs.html">simplified CommonJS wrapper</a> for those cases:
    </p>

    <pre><code>define(function(require, exports, module) {
        var a = require('a'),
            b = require('b');
        //Return the module value
        return function () {};
    }
);
</code></pre>
    <p>This wrapper relies on Function.prototype.toString() to give a useful string value of the function contents. This does not work on some devices like the PS3 and some older Opera mobile browsers. Use the <a href="optimization.html">optimizer</a> to pull out the dependencies in the array format for use on those devices.</p>
    <p>More information is available on the <a href="commonjs.html">CommonJS page</a>, and in the <a href="whyamd.html#sugar">"Sugar" section in the Why AMD page</a>.</p>
  </div>

  <div class="subSection">
    <h4><a href="#modulename" name="modulename">Define a Module with a Name</a><span class="sectionMark">&sect; 1.3.6</span></h4>
    <p>You may encounter some define() calls that include a name for the module as the first argument to define():</p>
    <pre><code>    //Explicitly defines the "foo/title" module:
    define("foo/title",
        ["my/cart", "my/inventory"],
        function(cart, inventory) {
            //Define foo/title object in here.
        }
    );
</code></pre>
    <p>These are normally generated by the <a href="optimization.html">optimization tool</a>. You can explicitly name modules yourself, but it makes the modules less portable -- if you move the file to another directory you will need to change the name. It is normally best to avoid coding in a name for the module and just let the optimization tool burn in the module names. The optimization tool needs to add the names so that more than one module can be bundled in a file, to allow for faster loading in the browser.</p>
  </div>
  <div class="subSection">
    <h4><a href="#modulenotes" name="modulenotes">Other Module Notes</a><span class="sectionMark">&sect; 1.3.7</span></h4>
    <p id="modulenotes-onemodule"><strong>One module per file.</strong>: Only one module should be defined per JavaScript file, given the nature of the module name-to-file-path lookup algorithm. You shoud only use the <a href="optimization.html">optimization tool</a> to group multiple modules into optimized files.</p>
    <p id="modulenotes-relative"><strong>Relative module names inside define()</strong>: For require("./relative/name") calls that can happen inside a define() function call, be sure to ask for "require" as a dependency, so that the relative name is resolved correctly:</p>
    <pre><code>define(["require", "./relative/name"], function(require) {
    var mod = require("./relative/name");
});
</code></pre>
    <p>Or better yet, use the shortened syntax that is available for use with <a href="commonjs.html">translating CommonJS</a> modules:</p>
    <pre><code>define(function(require) {
    var mod = require("./relative/name");
});
</code></pre>
    <p>This form will use Function.prototype.toString() to find the require() calls, and add them to the dependency array, along with "require", so the code will work correctly with relative paths.</p>
    <p>Relative paths are really useful if you are creating a few modules inside a directory, so that you can share the directory with other people or other projects, and you want to be able to get a handle on the sibling modules in that directory without
        having to know the directory's name.
    </p>
    <p id="modulenotes-relative-names"><strong>Relative module names are relative to other names, not paths</strong>: The loader stores modules by their name and not by their path internally. So for relative name references, those are resolved relative to the module name making the reference, then that module name, or ID, is converted to a path if needs to be loaded. Example code for a 'compute' package that has a 'main' and 'extras' modules in it:</p>
    <pre><code>* lib/
    * compute/
        * main.js
        * extras.js
</code></pre>
    <p>where the main.js module looks like this:</p>
    <pre><code>define(["./extras"], function(extras) {
    //Uses extras in here.
});
</code></pre>
    <p>If this was the paths config:</p>
    <pre><code>require.config({
    baseUrl: 'lib',
    paths: {
      'compute': 'compute/main'
    }
});
</code></pre>
    <p>And a <code>require(['compute'])</code> is done, then lib/compute/main.js will have the module name of 'compute'. When it asks for './extras', that is resolved relative to 'compute', so 'compute/./extras', which normalizes to just 'extras'. Since there is no paths configuration for that module name, the path generated will be for 'lib/extras.js', which is incorrect.</p>
    <p>For this case, <a href="#packages">packages configuration</a> is a better option, since it allows setting the main module up as 'compute', but internally the loader will store the module with the ID of 'compute/main' so that the relative reference for './extras' works.</p>
    <p>Another option is to construct a module at lib/compute.js that is just <code>define(['./compute/main'], function(m) { return m; });</code>, then there is no need for paths or packages configuration.</p>
    <p>Or, do not set that paths or packages configuration and do the top level require call as <code>require(['compute/main'])</code>.</p>
    <p id="modulenotes-urls"><strong>Generate URLs relative to module</strong>: You may need to generate an URL that is relative to a module. To do so, ask for "require" as a dependency and then use require.toUrl() to generate the URL:</p>
    <pre><code>define(["require"], function(require) {
    var cssUrl = require.toUrl("./style.css");
});
</code></pre>
    <p id="modulenotes-console"><strong>Console debugging</strong>: If you need to work with a module you already loaded via a <code>require(["module/name"], function(){})</code> call in the JavaScript console, then you can use  the require() form that just uses the string name of the module to fetch it:</p>
    <pre><code>require("module/name").callSomeFunction()
</code></pre>
    <p>Note this only works if "module/name" was previously loaded via the async version of require: <code>require(["module/name"])</code>. If using a relative path, like './module/name', those only work inside define</p>
  </div>
  <div class="subSection">
    <h4><a href="#circular" name="circular">Circular Dependencies</a><span class="sectionMark">&sect; 1.3.8</span></h4>
    <p>If you define a circular dependency ("a" needs "b" and "b" needs "a"), then in this case when "b"'s module function is called, it will get an undefined value for "a". "b" can fetch "a" later after modules have been defined by using the require() method (be sure to specify require as a dependency so the right context is used to look up "a"):</p>
    <pre><code>//Inside b.js:
define(["require", "a"],
    function(require, a) {
        //"a" in this case will be null if "a" also asked for "b",
        //a circular dependency.
        return function(title) {
            return require("a").doSomething();
        }
    }
);
</code></pre>
    <p>Normally you should not need to use require() to fetch a module, but instead rely on the module being passed in to the function as an argument. Circular dependencies are rare, and usually a sign that you might want to rethink the design. However, sometimes they are needed, and in that case, use require() as specified above.</p>
    <p>If you are familiar with CommonJS modules, you could instead use <strong>exports</strong> to create an empty object for the module that is available immediately for reference by other modules. By doing this on both sides of a circular dependency, you can then safely hold on to the the other module. This only works if each module is exporting an object for the module value, not a function:</p>
    <pre><code>//Inside b.js:
define(function(require, exports, module) {
    //If "a" has used exports, then we have a real
    //object reference here. However, we cannot use
    //any of "a"'s properties until after "b" returns a value.
    var a = require("a");
    exports.foo = function () {
        return a.bar();
    };
});
</code></pre>
    <p>Or, if you are using the dependency array approach, ask for the special
        <a href="https://github.com/jrburke/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic">'exports' dependency:</a>
    </p>
    <pre><code>//Inside b.js:
define(['a', 'exports'], function(a, exports) {
    //If "a" has used exports, then we have a real
    //object reference here. However, we cannot use
    //any of "a"'s properties until after "b" returns a value.
    exports.foo = function () {
        return a.bar();
    };
});
</code></pre>
  </div>
  <div class="subSection">
    <h4><a href="#jsonp" name="jsonp">Specify a JSONP Service Dependency</a><span class="sectionMark">&sect; 1.3.9</span></h4>
    <p><a href="http://en.wikipedia.org/wiki/JSON#JSONP">JSONP</a> is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</p>
    <p>To use a JSONP service in RequireJS, specify "define" as the callback parameter's value. This means you can get the value of a JSONP URL as if it was a module definition.</p>
    <p>Here is an example that calls a JSONP API endpoint. In this example, the JSONP callback parameter is called "callback", so "callback=define" tells the API to wrap the JSON response in a "define()" wrapper:</p>
    <pre><code>require(["http://example.com/api/data.json?callback=define"],
    function (data) {
        //The data object will be the API response for the
        //JSONP data call.
        console.log(data);
    }
);
</code></pre>
    <p>This use of JSONP should be limited to JSONP services for initial application setup. If the JSONP service times out, it means other modules you define via define() may not get executed, so the error handling is not robust.</p>
    <p><strong>Only JSONP return values that are JSON objects are supported</strong>. A JSONP response that is an array, a string or a number will not work.</p>
    <p>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</p>
    <p>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override requirejs.onError() to get errors. There is more information in the <a href="#errors">Handling Errors</a> section.</p>
  </div>

  <div class="subSection">
    <h4><a href="#undef" name="undef">Undefining a Module</a> <span class="sectionMark">&sect; 1.3.10</span></h4>
    <p>There is a global function, <b>requirejs.undef()</b>, that allows undefining a module. It will reset the
        loader's internal state to forget about the previous definition of the module.
    </p>
    <p>
      <b>However</b>, it will not remove the module from other modules that are already defined and got a
        handle on that module as a dependency when they executed. So it is really only useful to use in
        error situations when no other modules have gotten a handle on a module value, or as part of any future
        module loading that may use that module. See the <a href="#errbacks">errback section</a> for an example.
    </p>
    <p>If you want to do more sophisticated dependency graph analysis for undefining work, the semi-private
        <a href="https://github.com/jrburke/requirejs/wiki/Internal-API:-onResourceLoad">onResourceLoad API</a> may be helpful.
    </p>
  </div>

</div>
<div>
  <h3><a href="#reference" name="reference">Referencing a Module</a> <span class="sectionMark">&sect; 1.4</span></h3>
  <p>In traditional JavaScript, JavaScript code is referenced by providing the URL of the file containing the JavaScript code. RequireJS, on the other hand,
      takes a different approach. It encapsulates JavaScript code into logical entities called <strong>"Modules"</strong>, thereby abstracting the notion of a
      1:1 relationship between code and files.</p>

  <p>In fact, one single file may provide a number of modules, which drastically reduces download time if those modules are expected to be required together as a group, yet each module
      representing a distinct part of a library. The RequireJS <a href="optimization.html">Optimization tool</a>
    does exactly that: it bundles code from different JavaScript files into one single file while performing minification at the same time.</p>

  <p>Until RequireJS 2.1.10, however, module IDs still observed a 1:1 relationship between modules and files. This changed with the introduction of the <a href="#config-bundles">bundles</a>
    configuration option.</p>

  <h4><a href="#moduleID" name="moduleID">What is a Module ID?</a> <span class="sectionMark">&sect; 1.4.1</span></h4>

  <p>A <strong>module ID</strong> is a reference to an encapsulated JavaScript entity. Commonly there is only one single module present in a JavaScript file, but there
      may be occasions where there are more than one modules stored in a single file.</p>

  <p>A module ID basically is similar to a URL referencing a JavaScript file. In fact, you may use an URL wherever a module ID is expected without problem.</p>

  <p>But a module ID can do more:</p>

  <ul>
    <li>It is an identifier. So a module can be referenced by name and RequireJS takes care of whether to load the module and where to load it from.</li>
    <li>The paths and files to search for a module can be configured using the RequireJS <a href="#config">Configuration</a> object.</li>
  </ul>

  <p>A module ID basically is a configurable reference to a JavaScript file. The value of the module ID is either:</p>

  <ul>
    <li>a plain URL, if the module ID begins with either a protocol (e.g. "<code>http:</code>") or a slash ("<code>/</code>") or if it ends with the suffix ".js"</li>
    <li>a Javascript file name without ".js" extension, prepended by a path that may be an alias defined in the RequireJS configuration object's <a href="#config-paths">paths</a> property.</li>
    <li>A module identifier, defined in the RequireJS object's <a href="#config-shim">shim</a> or <a href="#config-bundles">bundles</a> property.</li>
  </ul>

  <p>If the JavaScript code identified by a module ID in a require() dependency statement has not been loaded yet, the corresponding URL gets computed and the JavaScript file
      gets downloaded. The exported JavaScript entities resulting from the downloaded file are then getting stored in the internal RequireJS dictionary using the module ID (or their given names)
      as identifier. Finally they are getting made available to the dependent code.</p>

  <h4><a href="#require" name="require">Executing code with dependencies: require()</a> <span class="sectionMark">&sect; 1.4.1</span></h4>

  <p>The RequireJS <a href="#define">define()</a> function encapsulates JavaScript entites and stores them into the RequireJS internal JavaScript entity dictionary. The <strong>require()</strong>
    function, however, doesn't add objects to the RequireJS internal dictionary. Instead it retrieves objects from the internal RequireJS dictionary, identified by one or more
      <a href="#moduleID">module IDs</a>, and utilizes them for execution:

      <pre><code>
// Defines a module with module ID "moduleID_1". The module returns the number 1.
define( "moduleID_1",   // module name/ID
      function() { return 1; }    // module content
      );

// Defines a module with module ID "moduleID_2". The module requires "moduleID_1"
// to execute and returns the value of moduleID_1 plus 2.
define( "moduleID_2",   // module name/ID
      ["moduleID_1"],   // dependencies to other modules
      function(mod1) { return mod1 + 2; }   // module content
      );

// Searches for module "moduleID_2", loads it if it doesn't already exist,
// moduleID_2 then searches, optionally loads and finally executes moduleID_1.
// Finally, the result of moduleID_2 gets logged into the console.
require( ["moduleID_2"],    // dependencies to modules
       function(mod2) console.log("1 + 2 = " + mod2   // code to execute
       );
      </code></pre>
  </p>

</div>
<div class="section">
  <h2>
    <a href="#mechanics" name="mechanics">Mechanics</a>
    <span class="sectionMark">&sect; 2</span>
  </h2>
  <p>RequireJS loads each dependency as a script tag, using head.appendChild().</p>
  <p>RequireJS waits for all dependencies to load, figures out the right order in which to call the functions that define the modules, then calls the module definition functions once the dependencies for those functions have been called. Note that the dependencies for a given module definition function could be called in any order, due to their sub-dependency relationships and network load order.</p>
  <p>Using RequireJS in a server-side JavaScript environment that has synchronous loading should be as easy as redefining require.load(). The build system does this, the require.load method for that environment can be found in build/jslib/requirePatch.js.</p>
  <p>In the future, this code may be pulled into the require/ directory as an optional module that you can load in your env to get the right load behavior based on the host environment.</p>
</div>
<div class="section">
  <h2>
    <a href="#config" name="config">Configuration Options</a>
    <span class="sectionMark">&sect; 3</span>
  </h2>
  <p>When using require() in the top-level HTML page (or top-level script file that does not define a module), a configuration object can be passed as the first option:</p>
  <pre><code>&lt;script src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script&gt;
  require.config({
    baseUrl: "/another/path",
    paths: {
        "some": "some/v1.0"
    },
    waitSeconds: 15
  });
  require( ["some/module", "my/module", "a.js", "b.js"],
    function(someModule,    myModule) {
        //This function will be called when all the dependencies
        //listed above are loaded. Note that this function could
        //be called before the page is loaded.
        //This callback is optional.
    }
  );
&lt;/script&gt;
</code></pre>
  <p>You may also call require.config from your <a href="api.html#data-main">data-main Entry Point</a>, but be aware that the data-main script is loaded asynchronously. Avoid other entry point scripts which wrongly assume that data-main and its require.config will always execute prior to their script loading.</p>
  <p>Also, you can define the configuration object as the global variable <code>require</code> <strong>before</strong> require.js is loaded, and have the values applied automatically.
      This example specifies some dependencies to load as soon as require.js defines require():
  </p>
  <pre><code>&lt;script&gt;
    var require = {
        deps: ["some/module1", "my/module2", "a.js", "b.js"],
        callback: function(module1, module2) {
            //This function will be called when all the dependencies
            //listed above in deps are loaded. Note that this
            //function could be called before the page is loaded.
            //This callback is optional.
        }
    };
&lt;/script&gt;
&lt;script src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>
  <p>
    <b>Note:</b> It is best to use <code>var require = {}</code> and do not use
      <code>window.require = {}</code>, it will not behave correctly in IE.
  </p>
  <p>There are a number of <a href="https://github.com/jrburke/requirejs/wiki/Patterns-for-separating-config-from-the-main-module">patterns for separating the configuration from main module loading</a>.</p>

  <h4>Supported configuration options:</h4>

  <dl>
    <dt id="config-baseUrl">
      <a href="#config-baseUrl">baseUrl</a>
    </dt>
    <dd>
      <h5>The root path to use for all module lookups.</h5>

      <p>If set, it will be used as the root path prepended to all <a href="#moduleID">module IDs</a>
        not being URLs.</p>

      <p>Defaults to the path of the document referencing RequireJS, or, if the &lt;script> tag loading RequireJS comes with a <a href="#data-main">data-main</a> attribute,
          to the directory of the file referenced by the data-main attribute.</p>

      <p>Given the following folder hierarchy:</p>
      <ul>
        <li>/
            <ul>
              <li>html/
                <ul>
                  <li>myPage.html</li>
                  <li>a.js</li>
                  <li>b.js</li>
                </ul>
              </li>
              <li>scripts/
                <ul>
                  <li>libs/
                    <ul>
                      <li>someLib.js</li>
                      <li>Require.js</li>
                    </ul>
                  </li>
                  <li>mine/
                    <ul>
                      <li>main.js</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
        </li>
      </ul>

      <p>&hellip; the following line:</p>
      <samp>
        <pre>    &lt;script type="text/javascript" <b>src="../scripts/libs.Require.js"</b>>&lt;/script></pre>
      </samp>
      <p>sets <strong>baseURL</strong> to "<samp>/html/</samp>".</p>

      <p>&hellip; the following line:</p>
      <samp>
        <pre>    &lt;script type="text/javascript" src="../scripts/libs.Require.js" <b>data-main="../scripts/mine/main"</b>>&lt;/script></pre>
      </samp>
      <p>sets <strong>baseURL</strong> to "<samp>/scripts/mine/</samp>".</p>

      <p>&hellip; and the following code:</p>
      <samp>
        <pre>    <b>&lt;script type="text/javascript"> var require = { baseURL: "/scripts/libs" }; &lt;/script></b>
    &lt;script type="text/javascript" src="../scripts/libs.Require.js" data-main="../scripts/mine/main">&lt;/script>
    &lt;script type="text/javascript"> require(["a.js", "b.js", "someLib"], function(a, b, c) {console.log("a = " + a + ", b = " + b + ", c = " + c); } ); &lt;/script></pre>
      </samp>
      <p>sets <strong>baseURL</strong> to "<samp>/scripts/libs/</samp>".</p>

      <p>baseUrl is <strong>not</strong> used when loading plain .js files (indicated by a dependency string <a href="#jsfiles">starting with a slash, has a protocol, or ends in .js</a>), those strings are used as-is, so a.js and b.js will be loaded from the same directory as the HTML page that contains the above snippet.</p>
      <p>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</p>
    </dd>

    <dt id="config-paths"><a href="#config-paths">paths</a></dt>
    <dd>
      <h5>Provides aliases for directories.</h5>

      <p>The main purpose of this property is to provide path mappings for module names not found directly under baseUrl.</p>

      <p>The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a "<samp>/</samp>" or has a URL protocol in it ("like
          <samp>http:</samp>").</p>

      <p>Given the following folder hierarchy:</p>
      <ul>
        <li>/
            <ul>
              <li>html/
                <ul>
                  <li>myPage.html</li>
                </ul>
              </li>
              <li>scripts/
                <ul>
                  <li>libs/
                    <ul>
                      <li>someLib.js</li>
                      <li>Require.js</li>
                    </ul>
                  </li>
                  <li>mine/
                    <ul>
                      <li>main.js</li>
                      <li>accessories.js</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
        </li>
      </ul>

      <p>&hellip; the following code:</p>
      <samp>
        <pre>
    <b>&lt;script type="text/javascript"> var require = { paths: { &quot;libs&quot; : "/scripts/libs" } }; &lt;/script></b>
    &lt;script type="text/javascript" src="../scripts/libs.Require.js" data-main="../scripts/mine/main">&lt;/script>
    &lt;script type="text/javascript"> require(["accessories", "libs/someLib"], function(a, sl) {console.log("a = " + a + ", sl = " + sl); } ); &lt;/script></pre>
      </samp>
      <p>Results in the <strong>path</strong> property setting replacing "<samp>libs</samp>" with "<samp>/scripts/libs</samp>".</p>

      <p>So in this example &hellip;</p>
      <ul>
        <li>"<samp>accessories.js</samp>" is loaded from "<samp>/scripts/mine/</samp>" as given by the <strong>data-main</strong> attribute,</li>
        <li>"<samp>someLib.js</samp>" is loaded from "<samp>/scripts/libs/</samp>" due to the <strong>paths</strong> alias for "libs".</li>
      </ul>

      <p>The path that is used for a module name should <strong>not</strong> include an extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path. If <a href="#modulenotes-urls">require.toUrl()</a> is used, it will add the appropriate extension, if it is for something like a text template.</p>
      <p>When run in a browser, <a href="#pathsfallbacks">paths fallbacks</a> can be specified, to allow trying a load from a CDN location, but falling back to a local location if the CDN location fails to load.</p>
    </dd>

    <dt id="config-bundles"><a href="#config-bundles">bundles</a></dt>
    <dd>
      <h5>Allows multiple modules to be stored in a single JavaScript file.</h5>

      <aside>Introduced in RequireJS 2.1.10.</aside>

      <p>Prior to the introduction of this property a single module could generally be addressed per file. File name and module ID had a 1:1 relation.</p>

      <p>With <strong>bundles</strong> it is now possible to define a number of <a href="#moduleID">module IDs</a> to be found in a single file. Within each <strong>bundles</strong> item, the
          key is the JavaScript file's <a href="#moduleID">module ID</a> while the value is an array of <a href="#moduleID">module IDs</a> which can be found in the file.</p>

      <p>This option requires all modules in the JavaScript file to have <a href="#modulename">names</a>.</p>

      <p>Example:</p>
      <pre><code>requirejs.config({
    bundles: {
        'primary': ['main', 'util', 'text', 'text!template.html'],
        'secondary': ['text!secondary.html']
    }
});
require(['util', 'text'], function(util, text) {
    //The script for module ID 'primary' was loaded,
    //and that script included the define()'d
    //modules for 'util' and 'text'
});
</code></pre>

      <p>The above configuration states: modules "<samp>main</samp>", "<samp>util</samp>", "<samp>text</samp>" and "<samp>text!template.html</samp>" will be found by loading module ID "<samp>primary</samp>".
          Module "<samp>text!secondary.html</samp>" can be found by loading module ID "<samp>secondary</samp>".</p>

      <p>This only sets up where to find a module inside a script that has multiple define()'d modules in it. It does not automatically bind those modules to the bundle's module ID. The bundle's module ID is just used for locating the set of modules.</p>

      <p>Something similar is possible with paths configuration, but it is much wordier, and the paths configuration route does not allow loader plugin resource IDs in its configuration, since the paths configuration values are path segments, not IDs.</p>

      <p>The <strong>bundles</strong> configuration property is useful in production scenarios when a library is to be shipped, consisting of distinct modules which are expected to all be used and shipped
          as a whole, doing a build and that build target was not an existing module ID, or if you have loader plugin resources in built JS files that should not be loaded by the loader plugin.</p>

      <p><strong>Note that the keys and values are module IDs</strong>, not path segments. They are <a href="#moduleID">module IDs</a>, not a module ID prefix like used in <a href="#config-paths">paths</a>
        or <a href="#config-map">map</a> configuration. Also, bundle configuration is different from map configuration in that map configuration is a 1:1 module ID relationship, where bundle configuration is
          for pointing multiple module IDs to a bundle's module ID.</p>
    </dd>

    <dt id="config-shim"><a href="#config-shim">shim</a></dt>
    <dd>

      <h5>Enables to create dependencies of traditional/legacy JavaScript code from within <a href="#require">require()</a> and <a href="#define">define()</a> by adding metadata necessary for asynchronous loading.</h5>

      <p>The <strong>shim</strong> property configures the dependencies, exports, and custom initialization for older, traditional, "browser globals" scripts that do not use define() to declare the dependencies and set a module value.</p>
      <p>Here is an example. It requires RequireJS 2.1.0+, and assumes backbone.js, underscore.js and jquery.js have been installed in the baseUrl directory. If not, then you may need to set a paths configuration for them:</p>
      <pre><code>requirejs.config({
    //Remember: only use shim config for non-AMD scripts,
    //scripts that do not already call define(). The shim
    //config will not work correctly if used on AMD scripts,
    //in particular, the exports and init config will not
    //be triggered, and the deps config will be confusing
    //for those cases.
    shim: {
        'backbone': {
            //These script dependencies should be loaded before loading
            //backbone.js
            deps: ['underscore', 'jquery'],
            //Once loaded, use the global 'Backbone' as the
            //module value.
            exports: 'Backbone'
        },
        'underscore': {
            exports: '_'
        },
        'foo': {
            deps: ['bar'],
            exports: 'Foo',
            init: function (bar) {
                //Using a function allows you to call noConflict for
                //libraries that support it, and do other cleanup.
                //However, plugins for those libraries may still want
                //a global. "this" for the function will be the global
                //object. The dependencies will be passed in as
                //function arguments. If this function returns a value,
                //then that value is used as the module export value
                //instead of the object found via the 'exports' string.
                //Note: jQuery registers as an AMD module via define(),
                //so this will not work for jQuery. See notes section
                //below for an approach for jQuery.
                return this.Foo.noConflict();
            }
        }
    }
});
//Then, later in a separate file, call it 'MyModel.js', a module is
//defined, specifying 'backbone' as a dependency. RequireJS will use
//the shim config to properly load 'backbone' and give a local
//reference to this module. The global Backbone will still exist on
//the page too.
define(['backbone'], function (Backbone) {
  return Backbone.Model.extend({});
});
</code></pre>
      <p>In RequireJS 2.0.*, the "<samp>exports</samp>" property in the shim configuration could have
      been a function instead of a string. In that case, it functioned
      the same as the "init" property as shown above. The "init" pattern is used in
      RequireJS 2.1.0+ so a string value for <code>exports</code> can be used for
      <a href="#config-enforceDefine">enforceDefine</a>, but then allow
      functional work once the library is known to have loaded.
      </p>
      <p>For "modules" that are just jQuery or Backbone plugins that do not need to export
      any module value, the shim configuration can just be an array of dependencies:
      </p>
      <pre><code>requirejs.config({
    shim: {
        'jquery.colorize': ['jquery'],
        'jquery.scroll': ['jquery'],
        'backbone.layoutmanager': ['backbone']
    }
});
</code></pre>
      <p>Note however if you want to get 404 load detection in IE so that you can  use paths fallbacks or errbacks, then a string
          <samp>exports</samp>
        value should be given so the loader can check if the scripts actually
      loaded (a return from init is <strong>not</strong> used for <code>enforceDefine</code> checking):
      </p>
      <pre><code>requirejs.config({
    shim: {
        'jquery.colorize': {
            deps: ['jquery'],
            exports: 'jQuery.fn.colorize'
        },
        'jquery.scroll': {
            deps: ['jquery'],
            exports: 'jQuery.fn.scroll'
        },
        'backbone.layoutmanager': {
            deps: ['backbone']
            exports: 'Backbone.LayoutManager'
        }
    }
});
</code></pre>
      <p><b>Important notes for "shim" configuration:</b></p>
      <ul>
        <li>The <strong>shim</strong> configuration property only sets up code relationships. To load modules that
        are part of or use the shim configuration property, a normal require()/define() call is needed. Setting <strong>shim</strong> by
        itself does not trigger code to load.
        </li>
        <li>Only use other "shim" modules as dependencies for shimmed scripts, or
        AMD libraries that have no dependencies and call define() after they also
        create a global (like jQuery or lodash). Otherwise, if you use an AMD
        module as a dependency for a shim configuration module, after a build, that
        AMD module may not be evaluated until after the shimmed code in the build
        executes, and an error will occur. The ultimate fix is to upgrade all the
        shimmed code to have optional AMD define() calls.
        </li>
        <li>If it is not possible to upgrade the shimmed code to use AMD define()
        calls, as of RequireJS 2.1.11, the optimizer has a
        <a href="https://github.com/jrburke/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68">wrapShim build option</a> that will
        try to automatically wrap the shimmed code in a define() for a build. This
        changes the scope of shimmed dependencies, so it is not guaranteed to always
        work, but, for example, for shimmed dependencies that depend on an AMD version of Backbone,
        it can be helpful.
        </li>
        <li>The init function will <strong>not</strong> be called for AMD modules.
        For example, you cannot use a shim init function to call jQuery's noConflict.
        See <a href="jquery.html#noconflictmap">Mapping Modules to use noConflict</a>
          for an alternate approach to jQuery.
        </li>
        <li>The <strong>shim</strong> configuration property is not supported when running AMD modules in node via RequireJS (it works for optimizer use though).
            Depending on the module being shimmed, it may fail in Node because Node does not have the same global environment as browsers.
            As of RequireJS 2.1.7, it will warn you in the console that the <strong>shim</strong> configuration property is not supported, and it may or may not work. If you wish to
            suppress that message, you can pass <code>requirejs.config({ suppress: { nodeShim: true }});</code>.</li>
      </ul>
      <p><strong>Important optimizer notes for the "shim" configuration property</strong>:</p>
      <ul>
        <li>You should use the <a href="optimization.html#mainConfigFile">mainConfigFile build option</a> to specify the file where to find the <strong>shim</strong> configuration property.
            Otherwise the optimizer will not know of the <strong>shim</strong> configuration property. The other option is to duplicate the <strong>shim</strong> configuration property in
            the build profile.</li>
        <li>Do not mix CDN loading with <strong>shim</strong> configuration in a build. Example scenario: you load jQuery from the CDN but use the <strong>shim</strong> configuration
            to load something like the stock version of Backbone that depends on jQuery. When you do the build, be sure to inline jQuery in the built file and do not load it from the CDN. Otherwise,
            Backbone will be inlined in the built file and it will execute before the CDN-loaded jQuery will load. This is because the <strong>shim</strong> configuration just delays loading
            of the files until dependencies are loaded, but does not do any auto-wrapping of define. After a build, the dependencies are already inlined, the <strong>shim</strong> configuration
            cannot delay execution of the non-define()'d code until later. define()'d modules do work with CDN loaded code after a build because they properly wrap their source in define factory
            function that will not execute until dependencies are loaded. So the lesson: <strong>shim</strong> configuration is a stop-gap measure for non-modular code, legacy code.
            define()'d modules are better.</li>
        <li>For local, multi-file builds, the above CDN advice also applies. For any shimmed script, its dependencies <strong>must</strong> be loaded before the shimmed script executes.
            This means either building its dependencies directly in the buid layer that includes the shimmed script, or loading its dependencies with a <code>require([], function (){})</code>
          call, then doing a nested <code>require([])</code> call for the build layer that has the shimmed script.</li>
        <li>If you are using uglifyjs to minify the code, <strong>do not</strong> set the uglify option <code>toplevel</code> to true, or if using the command line
            <strong>do not</strong> pass <code>-mt</code>. That option mangles the global names that shim uses to find exports.
        </li>
      </ul>
    </dd>

    <dt id="config-map"><a href="#config-map">map</a></dt>
    <dd>

      <h5>Redirects requests for configured module IDs to alternative module IDs.</h5>

      <p>This feature becomes important with larger projects which may use modules that need to use different versions of another module.</p>

      <p>map example:</p>
      <pre><code>requirejs.config({
    map: {
        'some/newmodule': {
            'foo': 'foo1.2'
        },
        'some/oldmodule': {
            'foo': 'foo1.0'
        }
    }
});
</code></pre>
      <p>If the modules are laid out on disk like this:</p>
      <ul>
        <li>foo1.0.js</li>
        <li>foo1.2.js</li>
        <li>some/
        <ul>
          <li>newmodule.js</li>
          <li>oldmodule.js</li>
        </ul>
        </li>
      </ul>
      <p>When 'some/newmodule' does `require('foo')` it will get the foo1.2.js file, and when 'some/oldmodule' does `require('foo')` it will get the foo1.0.js file.</p>

      <p>This feature only works well for scripts that are real AMD modules that call <a href="#define">define()</a> and register as anonymous modules. Also, <strong>only use absolute</strong>
        <a href="#moduleID">module IDs</a> for map configuration. Relative IDs (like <code>'../some/thing'</code>) do not work. It also won't work with the <a href="#multiversion">context-backed
            multiversion support</a>. In addition, the <a href="#config-paths">paths</a> configuration property is only for setting up root paths for module IDs, not for mapping one module ID
            to another one.</p>

      <p>There is also support for a "*" map value which means "for all modules loaded, use this map configuration". If there is a more specific map configuration, that one will take precedence over the
          star configuration.</p>

      <p>Example:</p>
      <pre><code>requirejs.config({
    map: {
        '*': {
            'foo': 'foo1.2'
        },
        'some/oldmodule': {
            'foo': 'foo1.0'
        }
    }
});
</code></pre>
      <p>The above means that for any module except "some/oldmodule", when "foo" is wanted, use "foo1.2" instead. For "some/oldmodule" only, use "foo1.0" when it asks for "foo".</p>

      <p id="config-map-notes"><strong>Note:</strong> when doing builds with map configuration, the map configuration needs to be fed to the optimizer, and the build output must still contain a requirejs
          configuration call that sets up the map configuration. The optimizer does not do ID renaming during the build, because some dependency references in a project could depend on runtime variable state.
          So the optimizer does not invalidate the need for a map configuration after the build.</p>
    </dd>

    <dt id="config-moduleconfig"><a href="#config-moduleconfig">config</a></dt>
    <dd>

      <h5>Pass configuration values to modules.</h5>

      <p>There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module.</p>

      <p>In RequireJS, that is done with the <strong>config</strong> configuration property. Modules can then read that info by asking for the special dependency
          "module" and calling <b>module.config()</b>.</p>

      <p>Configuration values are only provided to a module matching the <a href="#moduleID">module ID</a> provided in the <strong>config</strong> configuration property's key value.</p>

      <p>Example:</p>

      <pre><code>    requirejs.config(
    {
      config:
        {
          'bar': { size: 'large' },   // configuration for module ID "bar"
          'baz': { color: 'blue' }    // configuration for module ID "baz"
        }
    });

// The "bar.js" file, using simplified CJS wrapping:
// http://requirejs.org/docs/whyamd.html#sugar
define(function (require, exports, module) {
    var size = module.config().size;    // Will be the value 'large'
});

// The "baz.js" file, using a dependency array,
// Requesting the special module ID 'module':
// https://github.com/jrburke/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic
define(['module'], function (module) {
    var color = module.config().color;    //Will be the value 'blue'
});
</code></pre>
      <p>For passing config to a <a href="#packages">package</a>, target the main module in the package,
          not the package ID:
      </p>
      <pre><code>    requirejs.config({
    //Pass an API key for use in the pixie package's
    //main module.
    config: {
      'pixie/index': {
        apiKey: 'XJKDLNS'
      }
    },
    //Set up config for the "pixie" package, whose main
    //module is the index.js file in the pixie folder.
    packages: [
      {
        name: 'pixie',
        main: 'index'
      }
    ]
  });
</code></pre>
    </dd>

    <dt id="config-packages"><a href="#config-packages">packages</a></dt>
    <dd>

      <h5>Configures module loading from CommonJS packages.</h5>

      <p>See the <a href="#packages">packages topic</a> for more information.</p>
    </dd>

    <dt id="config-nodeIdCompat"><a href="#config-nodeIdCompat">nodeIdCompat</a></dt>
    <dd>

      <h5>Enables
          <samp>Node</samp>
        compatibility mode.</h5>

      <p>Node treats module IDs <code>example.js</code> and <code>example</code> the same. Yet these are two different IDs in RequireJS.</p>

      <p>If you end up using modules installed from npm, then you may need to set this configuration value to <code>true</code> to avoid resolution issues. Available in 2.1.10 and greater.</p>
    </dd>

    <dt id="config-waitSeconds"><a href="#config-waitSeconds">waitSeconds</a></dt>
    <dd>

      <h5>Script loading response timeout threshold.</h5>

      <p>The number of seconds to wait before giving up on loading a script. Setting it to
          <samp>0</samp>
        disables the timeout. The default is
          <samp>7</samp>
        seconds.</p>
    </dd>

    <dt id="config-context"><a href="#config-context">context</a></dt>
    <dd>

      <h5>A name to give to a loading context.</h5>

      <p>The <strong>context</strong> configuration property allows RequireJS to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string.</p>

      <p>To use it correctly, see the <a href="#multiversion">Multiversion Support</a> section.</p>
    </dd>

    <dt id="config-deps"><a href="#config-deps">deps</a></dt>
    <dd>

      <h5>An array of module dependencies to load immediately.</h5>

      <p>The <strong>deps</strong> configuration property is useful only when a <code>require</code> configuration object is defined before RequireJS is loaded, and you want to specify dependencies
          to load as soon as <a href="#require">require()</a> is defined.</p>

      <p>Using deps is just like doing a <code>require([])</code> call, but done as soon as the loader has processed the configuration. <strong>It does not block</strong>
        any other <code>require()</code> calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a configuration block.</p>

      <p>See <a href="#config-callback">callback</a> configuration property for registering a callback called when all dependencies defined by the <strong>deps</strong> configuration
          property have loaded.</p>
    </dd>

    <dt id="config-callback"><a href="#config-callback">callback</a></dt>
    <dd>

      <h5>Callback function to be executed after all dependencies defined by the "deps" configuration property have loaded.</h5>

      <p>A function to execute after all dependencies defined by the <a href="#config-deps">deps</a> configuration property have loaded.</p>

      <p>Useful only when a <code>require</code> configuration object is defined before RequireJS is loaded, and you want to specify a function to execute after the configuration's
          <strong>deps</strong> array's modules have been loaded.</p>
    </dd>

    <dt id="config-enforceDefine"><a href="#config-enforceDefine">enforceDefine</a></dt>
    <dd>

      <h5>Checks wheter all scripts either call define() or have a shim defined.</h5>

      <p>If set to true, an error will be thrown if a script loads that does not call <a href="#define">define()</a> or doesn't have a <a href="#config-shim">shim</a> exports string value
          that can be checked.</p>

      <p>See <a href="#ieloadfail">Catching load failures in IE</a> for more information.</p>
    </dd>

    <dt id="config-xhtml"><a href="#config-xhtml">xhtml</a></dt>
    <dd>

      <h5>Have RequireJS load scripts according to XHTML standard.</h5>

      <p>If set to <code>true</code>, <code>document.createElementNS()</code> will be used to create script elements.</p>
    </dd>

    <dt id="config-urlArgs"><a href="#config-urlArgs">urlArgs</a></dt>
    <dd>

      <h5>Adds query string arguments to all requests triggered by RequireJS.</h5>

      <p>The <strong>urlArgs</strong> configuration property provides an option to append query string arguments to URLs that RequireJS uses to fetch resources.</p>

      <p>Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for <strong>urlArgs</strong>:</p>
      <pre><code>urlArgs: "bust=" +  (new Date()).getTime()</code></pre>
      <p>During development it can be useful to use this, however <strong>be sure</strong> to remove it before deploying your code.</p>
    </dd>

    <dt id="config-scriptType"><a href="#config-scriptType">scriptType</a></dt>
    <dd>

      <h5>Specify the MIME type to be used for &lt;script> tags created by RequireJS.</h5>

      <p>The <strong>scriptType</strong> configuration attribute provides to provide a  value for the <code>type=""</code> attribute used for script tags inserted into the document by RequireJS.
          Default is <code>"text/javascript"</code>.</p>

      <p>Example: To use Firefox's JavaScript 1.8 features, use <code>"text/javascript;version=1.8"</code>.</p>
    </dd>

    <dt id="config-skipDataMain"><a href="#config-skipDataMain">skipDataMain</a></dt>
    <dd>

      <h5>Omits scanning the "data-main" attribute.</h5>

      <aside>Introduced in RequireJS 2.1.9.</aside>

      <p>If set to <code>true</code>, skips the <a href="#data-main">data-main</a> attribute scanning done to start module loading.</p>

      <p>Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.</p>
    </dd>
  </dl>

</div>
<div class="section">
  <h2>
    <a href="#advanced" name="advanced">Advanced Usage</a>
    <span class="sectionMark">&sect; 4</span>
  </h2>
  <h3><a href="#packages" name="packages">Loading Modules from Packages</a><span class="sectionMark">&sect; 4.1</span></h3>
  <p>RequireJS supports loading modules that are in a <a href="http://wiki.commonjs.org/wiki/Packages/1.1">CommonJS Packages</a> directory structure, but some additional configuration needs to be specified for it to work. Specifically, there is support for the following CommonJS Packages features:</p>
  <ul>
    <li>A package can be associated with a module name/prefix.</li>
    <li>The package configuration can specify the following properties for a specific package:
        <ul>
          <li><strong>name</strong>: The name of the package (used for the module name/prefix mapping)</li>
          <li><strong>location</strong>: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</li>
          <li><strong>main</strong>: The name of the module inside the package that should be used when someone does a require for "packageName". The default value is "main", so only specify it if it differs from the default. The value is relative to the package folder.</li>
        </ul>
    </li>
  </ul>
  <p><strong>IMPORTANT NOTES</strong></p>
  <ul>
    <li>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the <a href="commonjs.html#autoconversion">CommonJS converter tool</a> if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</li>
    <li>Only one version of a package can be used in a project context at a time. You can use RequireJS <a href="#multiversion">multiversion support</a> to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</li>
  </ul>
  <p>If you use a similar project layout as specified in the <a href="start.html">Start Guide</a>, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the <strong>scripts</strong> directory as the top-level project directory):</p>
  <ul>
    <li>project-directory/
        <ul>
          <li>project.html</li>
          <li>scripts/
            <ul>
              <li>require.js</li>
            </ul>
          </li>
        </ul>
    </li>
  </ul>
  <p>Here is how the example directory layout looks with two packages, <strong>cart</strong> and <strong>store</strong>:</p>
  <ul>
    <li>project-directory/
        <ul>
          <li>project.html</li>
          <li>scripts/
            <ul>
              <li>cart/
                <ul>
                  <li>main.js</li>
                </ul>
              </li>
              <li>store/
                <ul>
                  <li>main.js</li>
                  <li>util.js</li>
                </ul>
              </li>
              <li>main.js</li>
              <li>require.js</li>
            </ul>
          </li>
        </ul>
    </li>
  </ul>
  <p><strong>project.html</strong> will have a script tag like this:</p>
  <pre><code>&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>
  <p>This will instruct require.js to load scripts/main.js. <strong>main.js</strong> uses the "packages" configuration to set up packages that are relative to require.js, which in this case are the source packages "cart" and "store":</p>
  <pre><code>//main.js contents
//Pass a config object to require
require.config({
    "packages": ["cart", "store"]
});
require(["cart", "store", "store/util"],
function (cart,   store,   util) {
    //use the modules as usual.
});
</code></pre>
  <p>A require of "cart" means that it will be loaded from <strong>scripts/cart/main.js</strong>, since "main" is the default main module setting supported by RequireJS. A require of "store/util" will be loaded from <strong>scripts/store/util.js</strong>.</p>
  <p>If the "store" package did not follow the "main.js" convention, and looked more like this:</p>
  <ul>
    <li>project-directory/
        <ul>
          <li>project.html</li>
          <li>scripts/
            <ul>
              <li>cart/
                <ul>
                  <li>main.js</li>
                </ul>
              </li>
              <li>store/
                <ul>
                  <li>store.js</li>
                  <li>util.js</li>
                </ul>
              </li>
              <li>main.js</li>
              <li>package.json</li>
              <li>require.js</li>
            </ul>
          </li>
        </ul>
    </li>
  </ul>
  <p>Then the RequireJS configuration would look like so:</p>
  <pre><code>require.config({
    packages: [
        "cart",
        {
            name: "store",
            main: "store"
        }
    ]
});
</code></pre>
  <p>To avoid verbosity, it is strongly suggested to always use packages that use "main" convention in their structure.</p>
  <h3><a href="#multiversion" name="multiversion">Multiversion Support</a><span class="sectionMark">&sect; 4.2</span></h3>
  <p>As mentioned in <a href="#config">Configuration Options</a>, multiple versions of a module can be loaded in a page by using different "context" configuration options. require.config() returns a require function that will use the context configuration. Here is an example that loads two different versions of the alpha and beta modules (this example is taken from one of the test files):</p>
  <pre><code>&lt;script src="../require.js"&gt;&lt;/script&gt;
&lt;script&gt;
var reqOne = require.config({
  context: "version1",
  baseUrl: "version1"
});
reqOne(["require", "alpha", "beta",],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 1
  log("beta version is: " + beta.version); //prints 1
  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version1 omega loaded with version: " +
              omega.version); //prints 1
      }
    );
  }, 100);
});
var reqTwo = require.config({
      context: "version2",
      baseUrl: "version2"
    });
reqTwo(["require", "alpha", "beta"],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 2
  log("beta version is: " + beta.version); //prints 2
  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version2 omega loaded with version: " +
            omega.version); //prints 2
      }
    );
  }, 100);
});
&lt;/script&gt;
</code></pre>
  <p>Note that "require" is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If "require" is not specified as a dependency, then there will likely be an error.</p>
  <h3><a href="#afterload" name="afterload">Loading Code After Page Load</a><span class="sectionMark">&sect; 4.3</span></h3>
  <p>The example above in the <strong>Multiversion Support</strong> section shows how code can later be loaded by nested require() calls. </p>
  <h3><a href="#webworker" name="webworker">Web Worker Support</a><span class="sectionMark">&sect; 4.4</span></h3>
  <p>As of release 0.12, RequireJS can be run inside a Web Worker. Just use importScripts() inside a web worker to load require.js (or the JS file that contains the require() definition), then call require.</p>
  <p>You will likely need to set the <strong>baseUrl</strong> <a href="#config">configuration option</a> to make sure require() can find the scripts to load.</p>
  <p>You can see an example of its use by looking at one of the files used in <a href="http://github.com/jrburke/requirejs/blob/master/tests/workers.js">the unit test</a>.</p>
  <h3><a href="#rhino" name="rhino">Rhino Support</a><span class="sectionMark">&sect; 4.5</span></h3>
  <p>RequireJS can be used in Rhino via the <a href="download.html#rjs">r.js adapter</a>.
      See <a href="https://github.com/jrburke/r.js/blob/master/README.md">the r.js README</a> for more information.
  </p>
  <h3><a href="#nashorn" name="nashorn">Nashorn Support</a><span class="sectionMark">&sect; 4.6</span></h3>
  <p>As of RequireJS 2.1.16, RequireJS can be used in <a href="http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html">Nashorn</a>, Java 8+'s JavaScript engine, via the <a href="download.html#rjs">r.js adapter</a>.
      See <a href="https://github.com/jrburke/r.js/blob/master/README.md">the r.js README</a> for more information.
  </p>
  <h3><a href="#errors" name="errors">Handling Errors</a><span class="sectionMark">&sect; 4.7</span></h3>
  <p>The general class of errors are 404s for scripts (not found), network timeouts or errors in the scripts that are loaded. RequireJS has a few tools to deal with them: require-specific errbacks, a "paths" array configuration, and a global requirejs.onError.</p>
  <p>The error object passed to errbacks and the global requirejs.onError function will usually contain two custom properties:</p>
  <ul>
    <li><strong>requireType</strong>: A string value with a general classification, like "timeout", "nodefine", "scripterror".</li>
    <li><strong>requireModules</strong>: an array of module names/URLs that timed out.</li>
  </ul>
  <p>If you get an error with a requireModules, it probably means other modules that depend on the modules in that requireModules array are not defined.</p>
  <h4>
    <a href="#ieloadfail" name="ieloadfail">Catching load failures in IE</a>
    <span class="sectionMark">&sect; 4.6.1</span>
  </h4>
  <p>Internet Explorer has a set of problems that make it difficult to detect load failures for errbacks/paths fallbacks:</p>
  <ul>
    <li>script.onerror does not work in IE 6-8. There is no way to know if loading a script generates a 404, worse, it triggers the onreadystatechange with a complete state even in a 404 case.</li>
    <li>script.onerror does work in IE 9+, but it has a bug where it does not fire script.onload event handlers right after execution of script, so it cannot support the standard method of allowing anonymous AMD modules. So script.onreadystatechange is still used. However, onreadystatechange fires with a complete state before the script.onerror function fires.</li>
  </ul>
  <p>So it is very difficult with IE to allow both anonymous AMD modules, which are a core benefit of AMD modules, and reliable detect errors.</p>
  <p>However, if you are in a project that you know uses define() to declare all of its modules, or it uses the <a href="#config-shim">shim</a> configuration to specify string exports for anything that does not use define(), then if you set the <a href="#config-enforceDefine">enforceDefine</a> configuration value to true, the loader can confirm if a script load by checking for the define() call or the existence of the shim's exports global value.</p>
  <p>So if you want to support Internet Explorer, catch load errors, and have modular code either through direct define() calls or shim configuration, always set <b>enforceDefine</b> to be true. See the next section for an example.</p>
  <p><b>NOTE</b>: If you do set enforceDefine: true, and you use data-main="" to load your main JS module, then that main JS module <b>must call define()</b> instead of require() to load the code it needs. The main JS module can still call require/requirejs to set configuration values, but for loading modules it should use define().</p>
  <p>If you then also use <a href="https://github.com/jrburke/almond">almond</a> to build your code without require.js, be sure to use the <a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js#L413">insertRequire</a> build setting to insert a require call for the main module -- that serves the same purpose of the initial require() call that data-main does.</p>
  <h4>
    <a href="#errbacks" name="errbacks">require([]) errbacks</a>
    <span class="sectionMark">&sect; 4.6.2</span>
  </h4>
  <p>Errbacks, when used with <a href="#undef">requirejs.undef()</a>, will allow you to detect if a module fails to load, undefine
      that module, reset the configuration to a another location, then try again.
  </p>
  <p>A common use case for this is to use a CDN-hosted version of a library, but if
      that fails, switch to loading the file locally:
  </p>
  <pre><code>requirejs.config({
    enforceDefine: true,
    paths: {
        jquery: 'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min'
    }
});
//Later
require(['jquery'], function ($) {
    //Do something with $ here
}, function (err) {
    //The errback, error callback
    //The error has a list of modules that failed
    var failedId = err.requireModules && err.requireModules[0];
    if (failedId === 'jquery') {
        //undef is function only on the global requirejs object.
        //Use it to clear internal knowledge of jQuery. Any modules
        //that were dependent on jQuery and in the middle of loading
        //will not be loaded yet, they will wait until a valid jQuery
        //does load.
        requirejs.undef(failedId);
        //Set the path to jQuery to local path
        requirejs.config({
            paths: {
                jquery: 'local/jquery'
            }
        });
        //Try again. Note that the above require callback
        //with the "Do something with $ here" comment will
        //be called if this new attempt to load jQuery succeeds.
        require(['jquery'], function () {});
    } else {
        //Some other error. Maybe show message to the user.
    }
});
</code></pre>
  <p>With `requirejs.undef()`, if you later set up a different configuration and try to
      load the same module, the loader will still remember which modules needed
      that dependency and finish loading them when the newly configured module loads.
  </p>
  <p>
    <b>Note</b>: errbacks only work with callback-style require calls, not define()
      calls. define() is only for declaring modules.
  </p>
  <h4>
    <a href="#pathsfallbacks" name="pathsfallbacks">paths configuration fallbacks</a>
    <span class="sectionMark">&sect; 4.6.3</span>
  </h4>
  <p>The above pattern for detecting a load failure, undef()ing a module, modifying paths and reloading is a common enough request that there is also a shorthand for it. The paths configuration
      allows array values:</p>
  <pre><code>requirejs.config({
    //To get timely, correct error triggers in IE, force a define/shim exports check.
    enforceDefine: true,
    paths: {
        jquery: [
            'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min',
            //If the CDN location fails, load from this location
            'lib/jquery'
        ]
    }
});
//Later
require(['jquery'], function ($) {
});
</code></pre>
  <p>This above code will try the CDN location, but if that fails, fall back to the local lib/jquery.js location.</p>
  <p>
    <b>Note</b>: paths fallbacks only work for exact module ID matches. This is
      different from normal paths configuration which can apply to any part of a module ID
      prefix segment. Fallbacks are targeted more for unusual error recovery, not
      a generic path search path solution, since those are inefficient in the browser.
  </p>
  <h4>
    <a href="#requirejsonerror" name="requirejsonerror">Global requirejs.onError function</a>
    <span class="sectionMark">&sect; 4.6.4</span>
  </h4>
  <p>To detect errors that are not caught by local errbacks, you can override requirejs.onError():</p>
  <pre><code>requirejs.onError = function (err) {
    console.log(err.requireType);
    if (err.requireType === 'timeout') {
        console.log('modules: ' + err.requireModules);
    }
    throw err;
};
</code></pre>
</div>
<div class="section">
  <h2>
    <a href="#plugins" name="plugins">Loader Plugins</a>
    <span class="sectionMark">&sect; 5</span>
  </h2>
  <p>RequireJS supports <a href="plugins.html">loader plugins</a>. This is a way to support dependencies that are not plain JS files, but are still important for a script to have loaded before it can do its work. The RequireJS wiki has <a href="https://github.com/jrburke/requirejs/wiki/Plugins">a list of plugins</a>. This section talks about some specific plugins that are maintained alongside RequireJS:</p>
  <h3><a href="#text" name="text">Specify a Text File Dependency</a><span class="sectionMark">&sect; 5.1</span></h3>
  <p>It is nice to build HTML using regular HTML tags, instead of building up DOM structures in script. However, there is no good way to embed HTML in a JavaScript file. The best that can be done is using a string of HTML, but that can be hard to manage, particularly for multi-line HTML.</p>
  <p>RequireJS has a plugin, text.js, that can help with this issue. It will automatically be loaded if the text! prefix is used for a dependency. See the
      <a href="https://github.com/requirejs/text">text.js README</a> for more information.
  </p>
  <h3><a href="#pageload" name="pageload">Page Load Event Support/DOM Ready</a><span class="sectionMark">&sect; 5.2</span></h3>
  <p>It is possible when using RequireJS to load scripts quickly enough that they complete before the DOM is ready. Any work that tries to interact with the DOM should wait for the DOM to be ready. For modern browsers, this is done by waiting for the DOMContentLoaded event.</p>
  <p>However, not all browsers in use support DOMContentLoaded. The domReady module implements a cross-browser method to determine when the DOM is ready. <a href="download.html#domReady">Download the module</a> and use it in your project like so:</p>
  <pre><code>require(['domReady'], function (domReady) {
  domReady(function () {
    //This function is called once the DOM is ready.
    //It will be safe to query the DOM and manipulate
    //DOM nodes in this function.
  });
});
</code></pre>
  <p>Since DOM ready is a common application need, ideally the nested functions
      in the API above could be avoided. The domReady module also implements the <a href="plugins.html">Loader Plugin API</a>,
      so you can use the loader plugin syntax (notice the <b>!</b> in the domReady dependency) to force the
      require() callback function to wait for the DOM to be ready before executing. domReady will return
      the current document when used as a loader plugin:
  </p>
  <pre><code>require(['domReady!'], function (doc) {
    //This function is called once the DOM is ready,
    //notice the value for 'domReady!' is the current
    //document.
});
</code></pre>
  <p>
    <b>Note:</b> If the document takes a while to load (maybe it is a very large document, or has HTML script tags loading large JS files that block DOM completion until they are done), using domReady as a loader plugin may result in a RequireJS "timeout" error. If this a problem either increase the <a href="#config-waitSeconds">waitSeconds</a> configuration, or just use domReady as a module and
      call domReady() inside the require() callback.
  </p>
  <h3><a href="#i18n" name="i18n">Define an I18N Bundle</a><span class="sectionMark">&sect; 5.3</span></h3>
  <p>Once your web app gets to a certain size and popularity, localizing the strings in the interface and providing other locale-specific information becomes more useful. However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</p>
  <p>RequireJS allows you to set up a basic module that has localized information without forcing you to provide all locale-specific information up front. It can be added over time, and only strings/values that change between locales can be defined in the locale-specific file.</p>
  <p>i18n bundle support is provided by the i18n.js plugin. It is automatically loaded when a module or dependency specifies the i18n! prefix (more info below). <a href="download.html#i18n">Download the plugin</a> and put it in the same directory as your app's main JS file.</p>
  <p>To define a bundle, put it in a directory called "nls" -- the i18n! plugin assumes a module name with "nls" in it indicates an i18n bundle. The "nls" marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). If you wanted to provide a bundle of color names in your "my" set of modules, create the directory structure like so:</p>
  <ul>
    <li>my/nls/colors.js</li>
  </ul>
  <p>The contents of that file should look like so:</p>
  <pre><code>//my/nls/colors.js contents:
define({
    "root": {
        "red": "red",
        "blue": "blue",
        "green": "green"
    }
});
</code></pre>
  <p>An object literal with a property of "root" defines this module. That is all you have to do to set the stage for later localization work.</p>
  <p>You can then use the above module in another module, say, in a my/lamps.js file:</p>
  <pre><code>//Contents of my/lamps.js
define(["i18n!my/nls/colors"], function(colors) {
    return {
        testMessage: "The name for red in this locale is: " + colors.red
    }
});
</code></pre>
  <p>The my/lamps module has one property called "testMessage" that uses colors.red to show the localized value for the color red.</p>
  <p>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</p>
  <pre><code>//Contents of my/nls/colors.js
define({
    "root": {
        "red": "red",
        "blue": "blue",
        "green": "green"
    },
    "fr-fr": true
});
</code></pre>
  <p>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</p>
  <pre><code>//Contents of my/nls/fr-fr/colors.js
define({
    "red": "rouge",
    "blue": "bleu",
    "green": "vert"
});
</code></pre>
  <p>RequireJS will use the browser's navigator.languages, navigator.language or navigator.userLanguage property to determine what locale values to use for my/nls/colors, so your app does not have to change. If you prefer to set the locale, you can use the <a href="#moduleconfig">module configuration</a> to pass the locale to the plugin:</p>
  <pre><code>requirejs.config({
    config: {
        //Set the config for the i18n
        //module ID
        i18n: {
            locale: 'fr-fr'
        }
    }
});
</code></pre>
  <p><strong>Note</strong> that RequireJS will always use a lowercase version of the locale, to avoid case issues, so all of the directories and files on disk for i18n bundles should use lowercase locales.</p>
  <p>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is "en-us", then the "root" bundle will be used. If the locale is "fr-fr-paris" then the "fr-fr" bundle will be used.</p>
  <p>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</p>
  <pre><code>//Contents of my/nls/fr-fr/colors.js
define({
    "blue": "bleu",
    "green": "vert"
});
</code></pre>
  <p>Then the value for red in "root" will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</p>
  <ul>
    <li>my/nls/fr-fr-paris/colors.js</li>
    <li>my/nls/fr-fr/colors.js</li>
    <li>my/nls/fr/colors.js</li>
    <li>my/nls/colors.js</li>
  </ul>
  <p>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</p>
  <pre><code>//my/nls/colors.js contents:
define({
    "root": true,
    "fr-fr": true,
    "fr-fr-paris": true
});
</code></pre>
  <p>and the root bundle would look like:</p>
  <pre><code>//Contents of my/nls/root/colors.js
define({
    "red": "red",
    "blue": "blue",
    "green": "green"
});
</code></pre>
</div>
